name: transcendence
services:
  web-application-firewall:
    build:
      context: ./services/web-application-firewall
      dockerfile: Dockerfile
      args:
        MODSEC_VERSION: ${MODSEC_VERSION:-3.0.8}
        NGINX_VERSION: ${NGINX_VERSION:-1.22.1}
        LMDB_VERSION: ${LMDB_VERSION:-0.9.29}
    ports:
      - "8080:80"           # WAF wird auf Host‑Port 8080 verfügbar
      - "8443:8443"         # HTTPS Port für WAF

    depends_on:
      - api-gateway
    volumes:
      - ./services/web-application-firewall/configs/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./services/web-application-firewall/modsecurity.d:/etc/modsecurity.d:ro
      - ./services/web-application-firewall/html:/usr/share/nginx/html:ro
      - ./services/web-application-firewall/certs/server.crt:/etc/nginx/conf/server.crt:ro
      - ./services/web-application-firewall/certs/server.key:/etc/nginx/conf/server.key:ro
    networks:
      - api-network
    restart: unless-stopped

  api-gateway:
    build:
      context: .
      dockerfile: services/api-gateway/Dockerfile
          # Gate­way wird auf Host‑Port 3000 verfügbar
    depends_on:
      - auth-user-service
      - game-service
    environment:
      NODE_ENV: production
      LOG_LEVEL: ${LOG_LEVEL:-info} # Fallback 'info'
      GAME_SERVICE_UPSTREAM: http://game-service:3001
      AUTH_USER_SERVICE_UPSTREAM: http://auth-user-service:3002
    networks:
      - api-network
    volumes:
      - ./public:/app/public
    restart: unless-stopped

  game-service:
    build: ./services/game-service
    environment:
      NODE_ENV: production
      LOG_LEVEL: ${LOG_LEVEL:-info}
      JWT_SECRET: ${JWT_SECRET}
    networks:
      - api-network
    restart: unless-stopped
  
  auth-user-service:
    build: ./services/auth-user-service
    environment:
      NODE_ENV: production
      LOG_LEVEL: ${LOG_LEVEL:-info}
      JWT_SECRET: ${JWT_SECRET}
    networks:
      - api-network
    restart: unless-stopped
    volumes:
      - ./database:/app/database

  cli-client:
    build: ./cli
    network_mode: host
    profiles:
      - cli

  vault-seed-config:
    image: alpine:3.20
    profiles: [ "dev", "prod" ]
    volumes: 
      - ./services/vault/config/:/source:ro
      - ./services/vault/scripts/:/scripts:ro
      - vault-dev-config:/dest-dev
      - vault1-config:/dest-1
      - vault2-config:/dest-2
      - vault3-config:/dest-3
    entrypoint: ["sh", "/scripts/vault-seed-config.sh"]
    restart: "no"

  # --- Dev: Single node with local UI/CLI
  vault-dev-seed:
    image: alpine:3.20
    profiles: [ "dev" ]          # nur mit --profile dev
    volumes: 
      - vault-dev-runtime-certs:/destination
      - ./services/vault/scripts/:/scripts:ro
    environment:
      CN: "vault-dev"
      EXTRASAN: ",DNS:localhost,IP:127.0.0.1"
      DAYS: "7"
      DEST: "/destination"
    entrypoint: ["sh", "/scripts/vault-seed-cert.sh"]
    restart: "no"
    
  vault-bootstrap-dev:
    build:
      context: .
      dockerfile: services/vault/bootstrap/Dockerfile  # multi-stage: vault CLI + jq
    profiles: [ "dev" ]
    depends_on: [ vault-dev ]
    entrypoint: [ "sh", "/scripts/vault-bootstrap-dev.sh" ]
    environment:
      VAULT_ADDR: "https://vault-dev:8200"
      VAULT_SKIP_VERIFY: "1"
      ENABLE_MTLS_AT_END: "true"
      HOST_UID: "${HOST_UID:-1000}"               # Fallback 1000
      HOST_GID: "${HOST_GID:-1000}"               # Fallback 1000
    volumes:
      - ./services/vault/scripts:/scripts:ro                             # <— Skript nur gemountet
      - ./services/vault/policies:/policies:ro                           # <— Policies nur gemountet
      - vault-dev-runtime-certs:/certs/vault-dev:rw                       # RW für client.crt/key
      - vault-dev-config:/vault/config:rw                                 # RO für vault-dev.hcl
      - vault-dev-logs:/vault/logs                                          # RW für keys.json / Marker
      - ./services/ai-opponent/certs/:/certs/ai-opponent/:rw             # RW für ai-opponent
      - ./services/api-gateway/certs/:/certs/api-gateway/:rw             # RW für api-gateway
      - ./services/auth-user-service/certs/:/certs/auth-user-service/:rw # RW für auth-user-service
      - ./services/game-service/certs/:/certs/game-service/:rw           # RW für game-service
      - ./frontend-src/certs/:/certs/vite/:rw                           # RW für frontend
    networks: [ api-network ]
    restart: "no"

  vault-dev:
    image: hashicorp/vault:1.17
    profiles: [ "dev" ]
    user: "0:0"  
    entrypoint: vault server -config=/vault/config/vault-dev.hcl
    cap_add: [ "IPC_LOCK" ]
    ulimits: { memlock: -1 }
    volumes:
      - vault-dev-config:/vault/config:rw
      - vault-dev-runtime-certs:/vault/certs:ro
      - vault-dev-data:/vault/raft
      - vault-dev-logs:/vault/logs
    ports:
      - "127.0.0.1:8200:8200"
      - "127.0.0.1:8202:8202"
    networks: [ api-network ]

  # --- Prod/Staging: 3-node cluster (no host ports)
  vault-1-seed:
    image: alpine:3.20
    profiles: [ "prod" ]
    volumes: 
      - vault1-runtime-certs:/destination
      - ./services/vault/scripts/:/scripts:ro
    entrypoint: ["sh", "/scripts/vault-seed-cert.sh"]
    restart: "no"

  # vault-rotate:
  #   build: services/vault/rotate
  #   profiles: [ "dev" ]
  #   depends_on: [ vault-dev ]
  #   pid: "service:vault-dev"
  #   environment:
  #     VAULT_ADDR: "https://vault-dev:8200"
  #     VAULT_TOKEN: "${VAULT_ROTATE_TOKEN_DEV}"     # Policy: pki-rotate-vault-dev
  #     # mTLS-Pfade (werden im Script als Defaults gesetzt, können hier überschrieben werden)
  #     VAULT_CACERT: "/vault/rotator-certs/ca.crt"
  #     VAULT_CLIENT_CERT: "/vault/rotator-certs/agent.crt"
  #     VAULT_CLIENT_KEY: "/vault/rotator-certs/agent.key"

  #     ROLE: "vault-node-internal"
  #     CN: "vault-dev"
  #     ALT_NAMES: "vault-dev,localhost"
  #     IP_SANS: "127.0.0.1"
  #     CERT_DIR: "/vault/certs"
  #     NODE_CERT_TTL: "2160h"
  #     ROTATE_BEFORE_SECONDS: "604800"

  #     CLIENT_ROLE: "clients-internal"
  #     CLIENT_CN: "agent-vault-dev-rotator"
  #     CLIENT_CERT_DIR: "/vault/rotator-certs"
  #     CLIENT_TTL: "720h"
  #   volumes:
  #     - vault-dev-runtime-certs:/vault/certs:rw
  #     - vault-dev-rotator-certs:/vault/rotator-certs:rw
  #   restart: unless-stopped


  vault-1:
    image: hashicorp/vault:1.17
    profiles: [ "prod" ]          # nur mit --profile prod
    command: server -config=/vault/config/vault1.hcl
    cap_add: [ "IPC_LOCK" ]
    ulimits: { memlock: -1 }
    volumes:
      - vault1-config:/vault/config:ro
      - vault1-runtime-certs:/vault/certs:ro   # initiale Zertifikate von vault-1-seed
      - vault1-data:/vault/raft
      - vault1-logs:/vault/logs
    expose: [ "8200" ]
    networks: [ api-network ]

  vault-2:
    image: hashicorp/vault:1.17
    profiles: [ "prod" ]
    command: server -config=/vault/config/vault2.hcl   # mit retry_join auf vault-1
    cap_add: [ "IPC_LOCK" ]
    ulimits: { memlock: -1 }
    volumes:
      - vault2-config:/vault/config:ro
      - vault2-runtime-certs:/vault/certs:ro 
      - vault2-data:/vault/raft
      - vault2-logs:/vault/logs
    expose: [ "8200" ]
    networks: [ api-network ]

  vault-3:
    image: hashicorp/vault:1.17
    profiles: [ "prod" ]
    command: server -config=/vault/config/vault3.hcl   # mit retry_join auf vault-1
    cap_add: [ "IPC_LOCK" ]
    ulimits: { memlock: -1 }
    volumes:
      - vault3-config:/vault/config:ro
      - vault3-runtime-certs:/vault/certs:ro
      - vault3-data:/vault/raft
      - vault3-logs:/vault/logs
    expose: [ "8200" ]
    networks: [ api-network ]

networks:
  api-network:
    driver: bridge

volumes:
  vault-dev-config: {}
  vault-dev-data: {}
  vault-dev-logs: {}
  vault-dev-runtime-certs: {}

  vault1-config: {}
  vault1-data: {}
  vault1-logs: {}
  vault1-runtime-certs: {}

  vault2-config: {}
  vault2-data: {}
  vault2-logs: {}
  vault2-runtime-certs: {}

  vault3-config: {}
  vault3-data: {}
  vault3-logs: {}
  vault3-runtime-certs: {}
